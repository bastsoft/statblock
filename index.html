<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Statblock</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style>
        body { font-family: sans-serif; }
        .statblock { border: 1px solid #ccc; padding: 1em; max-width: 500px; margin: 1em auto; }
        .statblock h1 { font-size: 1.5em; margin-top: 0; }
        .statblock h2 { font-size: 1.2em; }
        .statblock .property { margin-bottom: 0.5em; }
        .statblock .property-display { font-weight: bold; }
        .statblock .group { border-top: 1px solid #ccc; margin-top: 1em; padding-top: 1em; }
        .statblock .inline { display: flex; justify-content: space-between; }
        .statblock .traits ul { padding-left: 1.5em; }
        .dice-roller { cursor: pointer; display: inline-block; }
        .dice-popup { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border: 1px solid #ccc; padding: 1em; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1000; }
        .dice-popup-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 999; }

    </style>
</head>
<body>
    <div id="app">
        <div v-if="layout && statblockData" class="statblock">
            <component v-for="block in layout.blocks" :is="getComponentName(block.type)" :block="block" :data="statblockData" :layout="layout"></component>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted } = Vue;

        const app = createApp({
            setup() {
                const statblockData = ref(null);
                const layout = ref(null);

                onMounted(async () => {
                    try {
                        // Construct URL from the hash part of the URL.
                        // Example URL: .../statblock/#/user/gist-id/...
                        const path = window.location.hash.substring(1); // Removes the leading '#'

                        const mechanicUrl = 'https://gist.githubusercontent.com' + path;
                        const mechanicResponse = await fetch(mechanicUrl);
                        if (!mechanicResponse.ok) {
                            throw new Error(`Failed to fetch Mechanic.md: ${mechanicResponse.statusText}`);
                        }
                        const mechanicText = await mechanicResponse.text();

                        // Extract layout URL from Mechanic.md
                        const layoutUrlRegex = /^layout:(.*)$/m;
                        const layoutUrlMatch = mechanicText.match(layoutUrlRegex);
                        const layoutUrl = layoutUrlMatch && layoutUrlMatch[1] ? layoutUrlMatch[1].trim() : 'starfinder.json';

                        // Parse statblock data from Mechanic.md
                        const statblockRegex = /```statblock\n([\s\S]*?)\n```/;
                        const match = mechanicText.match(statblockRegex);
                        if (match && match[1]) {
                            statblockData.value = jsyaml.load(match[1]);
                        }

                        // Fetch layout from the extracted or default URL
                        const layoutResponse = await fetch(layoutUrl);
                        layout.value = await layoutResponse.json();

                    } catch (error) {
                        console.error("Error loading data:", error);
                    }
                });

                const getComponentName = (type) => {
                    return type + '-block';
                };

                return {
                    statblockData,
                    layout,
                    getComponentName
                };
            }
        });

        const propertyMixin = {
            methods: {
                getProperty(prop) {
                    if (this.block.conditioned && !this.data[prop]) {
                        return null;
                    }
                    return this.data[prop] || this.block.fallback;
                }
            }
        };

        app.component('group-block', {
            props: ['block', 'data', 'layout'],
            template: `
                <div class="group">
                    <h2 v-if="block.heading">{{ block.heading }}</h2>
                    <component v-for="nestedBlock in block.nested" :is="getComponentName(nestedBlock.type)" :block="nestedBlock" :data="data" :layout="layout"></component>
                </div>
            `,
            methods: {
                getComponentName(type) {
                    return type + '-block';
                }
            }
        });

        app.component('inline-block', {
            props: ['block', 'data', 'layout'],
            template: `
                <div class="inline">
                    <component v-for="nestedBlock in block.nested" :is="getComponentName(nestedBlock.type)" :block="nestedBlock" :data="data" :layout="layout"></component>
                </div>
            `,
            methods: {
                getComponentName(type) {
                    return type + '-block';
                }
            }
        });


        app.component('heading-block', {
            mixins: [propertyMixin],
            props: ['block', 'data', 'layout'],
            template: `<h1 v-if="getProperty(block.properties[0])">{{ getProperty(block.properties[0]) }}</h1>`
        });

        app.component('subheading-block', {
            mixins: [propertyMixin],
            props: ['block', 'data', 'layout'],
            template: `<h3 v-if="getProperty(block.properties[0])">{{ getProperty(block.properties[0]) }}</h3>`
        });

        app.component('property-block', {
            mixins: [propertyMixin],
            props: ['block', 'data', 'layout'],
            template: `
                <div class="property" v-if="getProperty(block.properties[0])">
                    <span class="property-display">{{ block.display }} </span>
                    <template v-if="block.dice">
                        <dice-parser :text="getProperty(block.properties[0])"></dice-parser>
                    </template>
                    <template v-else>{{ getProperty(block.properties[0]) }}</template>
                </div>
            `
        });
        
        app.component('image-block', {
            mixins: [propertyMixin],
            props: ['block', 'data', 'layout'],
            data() {
                return {
                    imageUrl: ''
                };
            },
            template: `
                <div v-if="getProperty(block.properties[0])">
                    <img v-if="imageUrl" :src="imageUrl" :style="{height: layout.cssProperties.imageHeight || 'auto'}" />
                </div>
            `,
            async mounted() {
                this.imageUrl = this.getProperty(this.block.properties[0]);
            }
        });


        app.component('traits-block', {
            mixins: [propertyMixin],
            props: ['block', 'data', 'layout'],
            template: `
                <div class="traits" v-if="getProperty(block.properties[0])">
                    <h3 v-if="block.heading">{{ block.heading }}</h3>
                    <ul>
                        <li v-for="item in getProperty(block.properties[0])">
                            <strong>{{ item.name }}:</strong> 
                            <dice-parser v-if="block.dice" :text="item.desc"></dice-parser>
                            <template v-else>{{ item.desc }}</template>
                        </li>
                    </ul>
                </div>
            `
        });
        
        app.component('text-block', {
            mixins: [propertyMixin],
            props: ['block', 'data', 'layout'],
            template: `
                <div v-if="getProperty(block.properties[0])">
                    <h3 v-if="block.heading">{{ block.heading }}</h3>
                    <p>
                        <dice-parser v-if="block.dice" :text="getProperty(block.properties[0])"></dice-parser>
                        <template v-else>{{ getProperty(block.properties[0]) }}</template>
                    </p>
                </div>
            `
        });

        app.component('collapse-block', {
            props: ['block', 'data', 'layout'],
            data() {
                return {
                    isOpen: this.block.open
                }
            },
            template: `
                <div>
                    <button @click="isOpen = !isOpen">{{ isOpen ? 'Collapse' : 'Expand' }}</button>
                    <div v-if="isOpen">
                        <component v-for="nestedBlock in block.nested" :is="getComponentName(nestedBlock.type)" :block="nestedBlock" :data="data" :layout="layout"></component>
                    </div>
                </div>
            `,
            methods: {
                getComponentName(type) {
                    return type + '-block';
                }
            }
        });

        app.component('dice-parser', {
            props: ['text'],
            computed: {
                segments() {
                    if (typeof this.text !== 'string') return [];
                    // This regex finds dice formulas like (1d20+5) or (1 (1d20+5)) and captures the formula and surrounding text.
                    const regex = /(?:\(\d+\s*)?\((\d+d\d+(?:[+-]\d+)?)\)\)?/g;
                    const segments = [];
                    let lastIndex = 0;
                    let match;

                    while ((match = regex.exec(this.text)) !== null) {
                        if (match.index > lastIndex) {
                            segments.push({ type: 'text', content: this.text.substring(lastIndex, match.index) });
                        }
                        segments.push({ type: 'dice', content: match[1] });
                        lastIndex = regex.lastIndex;
                    }

                    if (lastIndex < this.text.length) {
                        segments.push({ type: 'text', content: this.text.substring(lastIndex) });
                    }

                    return segments;
                }
            },
            template: `
                <span v-for="segment in segments">
                    <template v-if="segment.type === 'text'">{{ segment.content }}</template>
                    <dice-roller v-if="segment.type === 'dice'" :formula="segment.content"></dice-roller>
                </span>
            `
        });

        app.component('dice-roller', {
            props: ['formula'],
            data() {
                return {
                    showPopup: false,
                    popupMessage: ''
                };
            },
            methods: {
                rollDice() {
                    try {
                        const match = this.formula.match(/(\d*)d(\d+)([+-]\d+)?/);
                        if (!match) throw new Error('Invalid dice formula');

                        const numDice = match[1] ? parseInt(match[1], 10) : 1;
                        const numSides = parseInt(match[2], 10);
                        const modifier = match[3] ? parseInt(match[3], 10) : 0;

                        let rolls = [];
                        let sum = 0;
                        for (let i = 0; i < numDice; i++) {
                            const roll = Math.floor(Math.random() * numSides) + 1;
                            rolls.push(roll);
                            sum += roll;
                        }

                        const total = sum + modifier;
                        let message = `Бросок: ${this.formula}. Выпало: ${rolls.join(', ')}.`;
                        if (numDice > 1 || modifier !== 0) {
                            let details = [];
                            if (numDice > 1) details.push(`Сумма: ${sum}`);
                            if (modifier !== 0) details.push(`Модификатор: ${modifier > 0 ? '+' + modifier : modifier}`);
                            details.push(`Итог: ${total}`);
                            message += ` ${details.join(', ')}`;
                        }
                        
                        this.popupMessage = message;
                        this.showPopup = true;

                    } catch (e) {
                        this.popupMessage = 'Ошибка при броске: ' + e.message;
                        this.showPopup = true;
                    }
                }
            },
            template: `
                <span @click="rollDice" class="dice-roller">🎲{{ formula }}</span>
                <div v-if="showPopup" class="dice-popup-overlay" @click="showPopup = false"></div>
                <div v-if="showPopup" class="dice-popup">
                    <p>{{ popupMessage }}</p>
                    <button @click="showPopup = false">Закрыть</button>
                </div>
            `
        });


        app.mount("#app");
    </script>
</body>
</html>
